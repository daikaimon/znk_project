# ソース改造および機能拡張のためのガイドライン
-----------------------------------

## <a name="index">目次
-----------------------------------
* [Hacking? ハッカーって奴っすかｗ？](#hacking)
* [Cooking? クッキーって奴っすかｗ？](#cooking)
* [開発言語および開発にあたっての背景など](#lang_and_background)
* [moai本体のソースコードの構成について](#moai_src)
* [libZnkについて](#libZnk)
* [プラグインインターフェース](#plugin)


## <a name="hacking">Hacking? ハッカーって奴っすかｗ？
-----------------------------------
そうっすよｗあのハッカーっすよｗ  
以下に正しい定義を書いておくっすよｗ

>「ハッカー」っていうのは良い子もみんなも知っている通り、コンピュータで悪いことする犯罪者で
>「ハッキング」ってのはハッカーがコンピュータで**けしからんこと**することである.

さて、こんなことを書くと我々の経験上、**鼻息を荒げながら**次のような反論をするおっさん(いやもはやジジイかｗ)が
いずこからともなく現れるのであったｗ

  ![screenshot](./imgs/keshikaran.png)

>**けしからん**のはお前さんの方だバカモノ！
>
>「ハッキング」っていうのは本来コンピュータを解析することであって、
>「ハッカー」はコンピュータを解析する者のことだ!
>コンピュータで悪いことする犯罪者は正しくは「クラッカー」と言い、
>コンピュータでけしからんことするのは「クラッキング」と言うのだ！
>
>二度と間違えるなｺﾞﾙｧ！(` Д´)／ﾊｱﾊｱ

まあ我々としては、もはや**こんな化石のような定義**など、今更どうでもいいわけだがｗ  
「ハッカー」っていう言葉は、コンピュータで悪いことする犯罪者として今や社会に浸透しているのだから.

…とここまで書いておいてアレだが、他に適当な言葉も思いつかなかったので
このファイル名も多くのオープンソースプロジェクトがそうしているようにHackingという名前にしちゃいましたですハイ!

ここでのHackingの意味は、**化石脳達**が言う意味に近いが、要するにこのツールを改造したり
拡張したりするといった程度の意味である(最近ではクラッキングという言葉がこの意味でも使われたりするようである).

というわけで、例によって前置きが長くなったが、このドキュメントはプログラマの方専用となっております.
プログラマでない方は、以下~~ネタの連発~~**専門用語の洪水**につきとっても危険なのでお逃げくださいｗ

  <a href="#user-content-index">目次へ戻る</a>


## <a name="cooking">Cooking? クッキーって奴っすか？
-----------------------------------
※本製品は観賞用であり、食べられません.

  ![screenshot](./imgs/do_not_eat.png)

  <a href="#user-content-index">目次へ戻る</a>


## <a name="lang_and_background">開発言語および開発にあたっての背景など
-----------------------------------

  さて、本題に入ろう.

  ここでは開発言語としてCを使ってある.
  そして今回リリースしたバージョンでは実行効率より確実性を最優先にしてある.

  C++ならばもっと記述は簡潔になる部分もあろうが、それは同時にデバッグの際における
  非シーケンシャルかつ非直感的な処理の割合が高くなることも意味する.
  特にコンストラクタやデストラクタの発動のタイミングやコンパイラ依存の差異や癖などですら、
  デバッガでも追跡困難なバグを誘発する.
  というわけで我々はどうでもいい開発にはC++を使うこともあるがそうではない場合はC++は
  基本的に使わない.
  ちなみに基本ライブラリであるlibZnkはC/C++いずれからでも使用可能である.

  その他メジャーなスクリプト言語(rubyやpythonなど)は大抵の場合良い選択だが、
  インタプリタや付属ライブラリのバージョンアップなどで、今まで問題なく動作していたものが
  突然エラーになるなどよくある話ではある. また万一その言語に未知のバグがあったり
  ドキュメントされていないある種の癖に由来した不具合が発生した場合、スクリプト環境
  に付属した膨大なコードから原因を探すなどやってられないので今回は不採用とした.

  このツールは本体そのものの改造や、プラグインによる拡張もしやすいと思う. 技術のある方は是非挑戦してもらいたい. 
  (特にMacOSへの対応は大いに歓迎する). 勿論あなたが書くのだからお好きな言語で書きなおしてもらってもいい.
  そして改造したものを是非とも公開して戴ければ我々にとってこれ以上の喜びはない
  (ソースコード公開の義務など微塵もないが、上に書いてある通り公開した方が
   より多くの人に使ってもらえる確率は高くなると思う). 

  ところでPolipoもCで記述されたオープンソースであり、実のところ当初はこれを改造して
  **Lolipo**(失礼ｗ)というツールでリリースする予定でいたのだが、Polipoのコードは関数名や
  グローバル変数名の命名規則や、それらの依存関係があまりに汚かった(失礼ｗ)ので、
  ~~ちょうどモアイ板も出来たことだし~~今回Moaiという新しいツールをフルスクラッチで開発する方が早いという結論に至った. 
  とはいえPolipoは非常に優れたツールであり、多くの部分を参考にさせてもらった.
  この場を借りてJuliusz Chroboczek氏には感謝する. ポート番号8123はPolipoで使われていたものであり、
  それに敬意を表しMoaiではこれのお隣という意味で8124をデフォルトポートとした.

  <a href="#user-content-index">目次へ戻る</a>


## <a name="moai_src">moai本体のソースコードの構成について
-----------------------------------
以下にMoaiを構成するファイルの概要を示す.
  <ul>
  <li>Moai_connection<br>
    MoaiConnection型とその寿命を管理する.
	MoaiConnectionとは、ProxyにおけるI側とO側のソケットをペアに持ち、その他それに関係する情報を保持する構造体である.
    ここで I側とはHTTPリクエストの発行元であり、O側とはそのリクエストをそのまま(あるいは加工して)送信する先である.
    またO側からそのリクエストに対する応答(レスポンス)が返され、I側へそれをそのまま(あるいは加工して)送信する形になる.
	TCPコネクション処理に関する管理やコールバックなどもここで保持する.
  </li>
  <li>Moai_info<br>
    MoaiInfo型とその寿命を管理する.
    MoaiInfoとはHTTPに関する必要な情報を保持する型である.
	また、MoaiInfoIDという64bit整数により、このMoaiInfo型本体へアクセスすることができるような機構を備える.
	(一種の連想配列である)
  </li>
  <li>Moai_io_base<br>
    ZnkSocketのクローズやそれらに関する報告用メッセージの作成補助、
	textデータのsend、パターンやサイズを加味したrecvを行う.
  </li>
  <li>Moai_post_vars<br>
    multitype/form-data形式で格納されたHTTP bodyをパースする.
  </li>
  <li>Moai_context<br>
    Moai_server内におけるscanHttpFirstから始まる一連の処理に使われる変数群を格納したもの.
  </li>
  <li>Moai_module<br>
    filterファイル(myf)やplugin(dll/so)などの管理やロード、関数の実行などを行う.
  </li>
  <li>Moai_post<br>
    POST変数やCookie変数のフィルタリングやpost_confirm用メッセージの構築などを行う.
  </li>
  <li>Moai_server<br>
    サーバ処理のコア部分であり、selectメインループが存在する.
    main関数から呼ばれたMoaiServer_mainは、config.myfやmoduleのロードなどの初期化処理を終えた後、
    ポート8124をリッスンし、selectメインループに入る.
    このループ内では MoaiFdSet_select においてデータの入力発生(read)や接続の成功(write)、タイムアウトの発生を待ち、
    これらのうちのいずれかが発生した場合に制御を返す. そして特にデータ入力発生(read)が発生した場合においては
    MoaiFdSet_process関数を介してrecv_and_sendがコールバックとして呼ばれ、入力されたデータの状態をまず
    scanHttpFirstで解析する形となる. この解析の結果、それがHTTPリクエストの開始であるのか、あるいはその応答の
    開始であるのか、あるいはそれらの途中の部分であるのかが明らかになる.
    またこの解析では中継先の取得も行われ、その結果によってWebサーバとして動作するのかローカルプロキシとして
    動作するのかの判断も行われる.
  </li>
  <li>Moai_log<br>
    ログ処理.
  </li>
  <li>Moai_fdset<br>
    selectイベントに関するsocketの登録、観察(Observe)用.
  </li>
  <li>Moai_parent_proxy<br>
    外部プロキシ(parent_proxy)に関する処理.<br>
	parent_proxy.txtの読み込みもここで行われる.
  </li>
  <li>Moai_myf<br>
    config.myf, target.myf, analysis.myfのロードと管理.
  </li>
  <li>Moai_enc_util<br>
    URLエンコーディングおよびデコーディング.
  </li>
  <li>main<br>
    勿論mainが存在するエントリー部である.
  </li>
  </ul>

  <a href="#user-content-index">目次へ戻る</a>


## <a name="libZnk">libZnkについて
-----------------------------------
この基本ライブラリはこのプロジェクトに存在する全てのCコードにおいて使われている.
よってこれの解説を抜きにするわけにはいかないのであるが、このライブラリの仕様を
詳しく解説していたらそれこそ紙面と時間がいくらあっても足らないので、
とりあえず[libZnk/README][1]に**猛烈に手抜きな**概要を書いておいた.
あとはlibZnkのソースコードやコメントなどを適宜参照して戴きたい.
時間があればそのうち詳細なドキュメントも用意したいところであるが、いつになるかは未定である.

  <a href="#user-content-index">目次へ戻る</a>


## <a name="plugin">プラグインインターフェース
-----------------------------------

Moaiプラグインでは以下のダイナミックロード可能なグローバル関数を C 言語により実装する.
このバージョンにおいてサポートされる関数は以下である.

~~~c

  bool initiate( ZnkMyf ftr_send, const char* parent_proxy, ZnkStr result_msg );

    target固有のsendフィルタの初期化処理を行う.
    Web Configurationの「Virtual USERS Initiation」ボタンを押すとこの関数が呼び出される.
    
    @param ftr_send:
     初期化対象となるフィルタへの参照である.
     pluginはこの関数内でこの値を参照および変更してかまわない.
	 これにより、ヘッダ、ポスト変数、Cookie変数の特別な初期化(仮想化やランダマイズ化)が可能となるだろう.
    
    @param parent_proxy:
     Moaiが現在使用中の外部プロキシがhostname:portの形式で設定されている.
     (外部プロキシを使用していない場合はこの値が空値であるかまたはNONEであるかまたは:0が指定されている)
     pluginはこの関数内でこの値の参照は可能だが変更することはできない.
    
    @param result_msg:
     ここにはこの関数の処理をおこなった結果のメッセージを格納しなければならない.
     これは処理が成功した場合はそれをリポートメッセージであり、エラーが発生した場合はそれを示す
     エラーメッセージとなる.
     「Virtual USERS Initiation」ボタンを押すとすぐ下にこのメッセージが表示される形になる.


  bool on_post( ZnkMyf ftr_send );

    target固有のPOST直前時の処理を行う.
    POST直前に毎回呼び出される.

    @param ftr_send:
     処理対象となるフィルタへの参照である.
     pluginはこの関数内でこの値を参照および変更してかまわない.
	 これにより、ヘッダ、ポスト変数、Cookie変数のさらなる柔軟なフィルタリングが可能となるだろう.


  bool on_response( ZnkMyf ftr_send,
  		ZnkVarpAry hdr_vars, ZnkStr text, const char* req_urp );

    target固有のレスポンスを受け取った場合における処理を行う.
    レスポンスを受け取った場合に毎回呼び出される.
	text(これはHTML,CSS,Javascriptなどであったりする)を加工することが主な目的となるだろう.

    @param ftr_send:
     処理対象となるフィルタへの参照である.
     pluginはこの関数内でこの値を参照および変更してかまわない.
   
    @param hdr_vars:
     処理対象となるレスポンスヘッダへの参照である.
     pluginはこの関数内でこの値を参照および変更してかまわない.
   
    @param text:
     処理対象となるレスポンステキストデータへの参照である.
     pluginはこの関数内でこの値を参照および変更してかまわない.
   
    @param req_urp:
     処理対象となるURIのpath部分(URIにおけるオーソリティより後ろの部分)が渡される.
     pluginはこの関数内でこの値の参照は可能だが変更することはできない.

~~~

上記に出現するlibZnk特有の型に関して以下に極簡単に紹介しておこう.

~~~c

  ZnkMyf
    libZnkが提供する汎用の設定用ファイルフォーマットmyfのデータを格納するための構造体である.
    全フィールドは隠蔽されており、それらに対する操作はすべて関数を通じて行う.
    インターフェースはZnk_myf.h によって提供され、Znk_myf.cがその実装部である.

  ZnkStr
    libZnkが提供する動的拡張可能な汎用文字列型を実現するための構造体である.
    全フィールドは隠蔽されており、それらに対する操作はすべて関数を通じて行う.
    インターフェースはZnk_str.h によって提供され、Znk_str.cがその実装部である.
    (実装にあたってはZnkBfr(Znk_bfr.h)というさらに基本的な汎用バイト列型を利用している)

  ZnkPrim
    以下を格納可能なコンテナというか汎用型である.
    整数、実数、ポインタ、
    バイト列データZnkBfr、ZnkBfrの配列、
    文字列ZnkStr、ZnkStrの配列、
    ZnkPrimそのものの配列
    フィールドは公開されているが、異コンパイラ間でのポータビリティに配慮すべく
    アラインメントに関して可能な限りの配慮がなされている.

    以下のような形で使用する.
    {
      ZnkPrim prim;
      ZnkPrimType type;
      ZnkPrim_compose( &prim, ZnkPrim_e_Real ); /* 初期化 */

      type = ZnkPrim_type( &prim ); /* 内部にどのタイプの値が入っているかを取得 */
      if( type == ZnkPrim_e_Real ){
        prim.r64_ = 0.123; /* 内部が実数型なら実数をセットするなど */
      }

      ZnkPrim_dispose( &prim ); /* 破棄 */
    }
    インターフェースはZnk_prim.h によって提供される.

  ZnkVarp
    ZnkPrimに加え、nameとfilenameをそのフィールドに持つ.
    いわゆる「変数」のような構造を実現した型である.
    すなわちnameが変数名であり、ZnkPrimがその値となる.
    主な関数を一部紹介しよう.
    ZnkVar_compose で初期化が行え、ZnkVar_dispose で破棄を行う.
    ZnkVar_name_cstr( ZnkVar* var ) は変数の名前をC文字列として取得する.
    ZnkVar_set_val_Str は文字列型の変数として変数を初期化する.
    ZnkVar_cstr( ZnkVar* var ) は var が文字列型変数の場合に限り使用できる簡易関数で
    その変数としての値をC文字列として取得できる.
    インターフェースはZnk_var.h によって提供され、Znk_var.cがその実装部である.

  ZnkVarpAry
    ZnkVarpの動的拡張可能な配列である.
    HTTPヘッダ全体、POST変数群、Cooking変数群などは要するにすべて(値が文字列型である)
    変数の配列であって、いずれもこの型で実現できる.
    インターフェースはZnk_varp_ary.h によって提供され、Znk_varp_ary.cがその実装部である.
    (実装にあたってはZnkObjAry(Znk_obj_ary.h)というさらに基本的なポインタ型汎用配列を利用している)

~~~

  <a href="#user-content-index">目次へ戻る</a>


[1]: https://github.com/mr-moai-2016/znk_project/blob/master/src/libZnk/README.md
