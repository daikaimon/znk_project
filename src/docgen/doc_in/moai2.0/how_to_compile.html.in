@def_quote [' ']

@@V config
doc_title = ['Moai+Easter 上級マニュアル']
author = { ['Mr.Moai'] ['Zenkaku'] }
update = ['2019/12/10']
category_path = { ['moai2_0_exp'] }
urp           = ['/moai2.0/how_to_compile.html']
nb_tags = { ['div'] ['ul'] ['ol'] ['li'] }
@@.

@@L AtFirst
	この記事では、Moaiのソースコードから実行バイナリ(exeファイル等)を作る手順について、全くの初心者でもできるように丁寧に説明します.
	この作業を<b>コンパイル</b>、これを行うためのツールを<b>コンパイラ</b>と呼びます.
	コンパイルは<b>ビルド</b>と呼ばれることもあります.
	作成した実行バイナリとそれに付属するその他のファイルは、最終的に所定の位置へコピーする必要がありますが、この過程を<b>インストール</b>と呼びます.
@@.

@@P Index
{ ['#WhyWeCompile']      ['なぜソースコードからコンパイルするのか？'] }
{ ['#get_source_code']   ['Moaiのソースコードの入手方法'] }
{ ['#introduction']      ['はじめてのコンパイル'] }
{ ['#get_mingw']         ['MinGWの入手と開発環境の構築'] }
{ ['#compile_by_mingw']  ['Windows版をコンパイルする(MinGWを使用)'] }
{ ['#compile_by_vc']     ['Windows版をコンパイルする(VCを使用)'] }
{ ['#compile_on_cygwin'] ['Windows版をコンパイルする(Cygwinを使用)'] }
{ ['#compile_on_msys']   ['Windows版をコンパイルする(MSYSを使用)'] }
{ ['#compile_on_others_windows'] ['Windows版をコンパイルする(BCC5.5(Borland C++ Compiler 5.5)またはDMC(Digital Mars C/C++)を使用)'] }
{ ['#compile_on_linux']  ['Linux版をコンパイルする'] }
{ ['#compile_for_android_term'] ['Android Terminal Emulator版をコンパイルする'] }
{ ['#compile_for_apk']   ['Android APK版を作成する[執筆中]'] }
{ ['#about_libressl']    ['付属ライブラリlibresslについて'] }
{ ['#about_macos']       ['MacOSについて'] }
@@.


@@L WhyWeCompile
	Moaiはオープンソースなツールでありソースコードを公開していますが、世にある多くのツールと同様に実行形式(実行バイナリとも呼びます)も提供しています.
	これらはWindows版とLinux版とAndroid版の実行形式であり、それぞれの環境でただちに実行して使うことができます.
	勿論、提供されている実行形式をそのまま使っていただいてかまいません.
	多くの方は普通そうされるかと思います. そのような方についてはこの記事は不要です.
	ではなぜソースコードからわざわざコンパイルして使う方法をここで解説するのでしょうか？
	
	中にはこのバイナリが<b>安全であるという確証</b>がなければ安心して使えないという用心深い方もおられると思います.
	残念ながら「いくらこれは安全です」と作者である我々が言ったところで、ほとんど何の確証にもなりません.
	おかげさまで我々が今まで開発してきたツールのことを皆様は大分よく知っていて、そのような心配をなさる方も最近は見られなくなってはきたのですが、<\>
	そうではない方にとってはこれに関する唯一確実な方法はソースコードを見て納得してもらう他ありません. 
	
	とはいえ、我々プログラマでさえオープンソースのツールを使うとき、そのコードの隅々まで読んでから使うなど稀なことです.
	ましてやプログラマでもない方にこれをせよというのは酷というものでしょう.
	
	ではどうすればよいでしょうか？ 現時点で我々の出せるその答えとしては以下のようなものです.
	<ul>
		<li><b>ソースコードが公開されている事実だけでよしとして、それ以上は気にしないという考え方.</b>
		割とこのような方が多いのかもしれません. この記事の筆者もこのタイプです.
		</li>
		
		<li><b>ソースコードの内容を一応検査してから使う.</b>
		あなたにプログラミングに詳しい知り合いがいるなら、このソースコードをざっくりとチェックしてもらう.
		そんな知り合いはいない方は、プログラミングを扱う掲示板などでこのツールのソースコードのありか(GithubのURL)を記す.
		そしてこのツールのソースコードについての意見を聞き、あなたなりの納得を得る.
		</li>
		
		<li><b>付属するソースコードを自らがコンパイルしてそれを使用する.</b>
		勿論、我々が提供している実行バイナリは、このソースコードからコンパイルしたものに他なりません.
		ですが例えばあなたがそのことを疑って、本当にそうであるという確証が欲しいと思ったとします.
		そのためには、あなた自らがソースコードをコンパイルし、出来上がった実行バイナリを使ってもらうしかありません.
		</li>
	</ul>
	というわけで、この記事では主にMinGWを例にコンパイラの入手方法、インストール/設定方法、実行方法に至るまで、<\>
	全くの初心者でもわかるようこれでもかというくらい丁寧にその手順を書いたつもりです.
	機械的な作業なので言うほど難しくはない…と我々は思うのですが….
	
	普段は別に気にせず配布されている実行形式を使っているが、Moaiのソースコードにも興味あるのでコンパイルもしてみたいという技術派な方にとっても有用な内容となっています.
@@.


@@L get_source_code
	現在の最新版はzipファイルとなっており、以下より入手できます.
	
	<a class=MstyWrapLink href=https://github.com/mr-moai-2016/znk_project/releases/latest>https://github.com/mr-moai-2016/znk_project/releases/latest</a>
	
	ソースコードはAssetsにあるSource code とあるzipファイルにアーカイブとしてまとめられているので、これをダウンロードします.
	これはお使いのPCのどのディレクトリへダウンロードして展開してもらっても構いません.
@@.



@@L introduction
<article class="message is-dark">
	<div class="message-header">
		基本知識
	</div>
	<div class="message-body">
		ソースコードからのコンパイルなどやったことがない、あるいは何から手をつければよいかわからないと言う方も多いことでしょう.
		C/C++での開発において最低限必要となる基本コマンドは、以下の通りです.
		<ul>
			<li><b>Cコンパイラ</b>
			Cファイルをオブジェクトファイルに変換します.
			ここで言うオブジェクトファイルとは、最終的な実行バイナリ(アプリ)になる前の中間形態のファイルという程度の認識で十分です.
			</li>
			<li><b>C++コンパイラ</b>
			C++ファイルをオブジェクトファイルに変換します.
			</li>
			<li><b>リンカ</b>
			オブジェクトファイルやライブラリを寄せ集めて最終的な実行バイナリに変換します.
			あるいは動的ライブラリを作成する場合もこれを使います.
			</li>
			<li><b>ライブラリアン</b>
			オブジェクトファイルを寄せ集めて静的なライブラリを作成します.
			</li>
			<li><b>ビルドスクリプト</b>
			通常は上記のコマンドを必要に応じて定義された規則で呼び出すビルドスクリプトを使います.
			これがなくても上記のコマンド群は単独で実行可能なので厳密に言えばこれは必須コマンドではありません.
			しかし、そのような単独実行を毎回イチイチやっていては大変な手間となるのでこのビルドスクリプトは準必須項目と考えてよいでしょう.
			現在数多くのビルドスクリプトが出回っているようですが、ここではその代表例として Makefile を使います.
			</li>
		</ul>
		よって、まずはこれらのコマンドツール一式を取り揃える必要があります.
		色々あって大変と思われるかもしれませんが、心配ありません.
		以下でこれについても詳しく説明いたします.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		Windows版をコンパイルしてみたい方へ
	</div>
	<div class="message-body">
		<ul>
			<li><b>コンパイラなど使ったことないという方</b>
			<b>MinGW</b>と呼ばれているCコンパイラを使うとよいでしょう.
			<a class=MstyElemLink href=#get_mingw>MinGWの入手と開発環境の構築</a>の項へと進みましょう.
			</li>

			<li><b>既にMinGWをインストールしてある方</b>
			<a class=MstyElemLink href=#compile_by_mingw>WindowsでMinGWを使ってコンパイルする</a>を参照して下さい.
			</li>

			<li><b>MinGWではなくVC(Visual C++)を使いたいという方</b>
			<a class=MstyElemLink href=#compile_by_vc>WindowsでVCを使ってコンパイルする</a>を参照して下さい.
			<div class=box>
				VCの入手とインストール方法についてはここでは解説しません. 
				多分、こちらを選ばれる方は、ある程度わかっている方だと思うので.
				Microsoftよりフリーで提供されているVCとして Visual Studio Express がありますが、通常はそれで十分です.
			</div>
			</li>

			<li><b>上記どれでもないCコンパイラを使いたいという方</b>
			目次よりご希望のコンパイラ環境があればそれを参照してください.
			</li>
		</ul>
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		Linux版をコンパイルしてみたい方へ
	</div>
	<div class="message-body">
		<a class=MstyElemLink href=#compile_on_linux>Linux版をコンパイルする</a>を参照して下さい.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		Android版をコンパイルしてみたい方へ
	</div>
	<div class="message-body">
		<a class=MstyElemLink href=#compile_for_android_term>Android版をコンパイルする</a>を参照して下さい.
		ただしこれは特に開発環境の構築が初心者にはかなり難しいです.
		バージョン間の組み合わせによっては相性の問題が出たりと色々と厄介な要素もあり、忍耐力も必要になるかと思います.
	</div>
</article>
@@.


@@L get_mingw
<article class="message is-dark">
	<div class="message-header">
		MinGW Cコンパイラのインストール
	</div>
	<div class="message-body">
		MinGWはメジャーなC言語コンパイラであり、入手およびインストール方法が解説されたサイトはごまんとありますが、この記事でも私流に説明しておきましょう.
		
		まずダウンロードサイトである<a class=MstyWrapLink href=https://sourceforge.net/downloads/mingw target=_blank>https://sourceforge.net/downloads/mingw</a>へアクセスします.
		<div class=box>
			MinGWの公式サイトは<a class=MstyWrapLink href=http://www.mingw.org target=_blank>http://www.mingw.org</a>です.
			しかしダウンロードするファイル群はそこではなく、そのすべてが sourceforge の方へ置いてあります.
			公式サイトのDownloadsリンクから迂回しても結局上記と同じ場所に導かれます.
		</div>
		
		「Download Latest Version mingw-get-setup.exe」と書かれた一番目立つ緑のボタンがあると思うので、それをクリックします.
		mingw-get-setup.exe を促すダイアログが出るのでそれをダウンロードします.
		たとえばC:\MinGWというフォルダを作ってその中に保存しておくとよいでしょう.
		(これのファイルサイズは85KBと極めて小さいです).
		
		次にこの mingw-get-setup.exe を実行します.
		このプログラムはMinGWのインストーラを自動でダウンロードするといういわば<b>インストーラをインストールするインストーラ</b>です(わかりにくい言い回しですが).
		
		さて、これを実行したらいよいよインストールのスタートです.
		次の手順で行います.
		
		<ol>
			<li>多分最初に<s>アホな</s>Windowsが「セキュリティの警告」を表示してくるかもしれません.
			ですが<b>MinGWにその種の問題があろうはずもない</b>ので、構わず「実行」します.
			</li>
			
			<li>「MinGW Installation Manager Setup Tool」ウィンドウが表示されるので「Install」を押します.
			</li>
			
			<li>次の画面でインストール先を指定できます. 
	
			<div class=box>
				デフォルトでは C:\MinGWとなっていますが「Change」でこれを変えることもできます.
				その場合は以下の説明で C:\MinGW となっている部分をそのフォルダで読み替えて下さい.
				最終的に180MB程度必要ですので、万一余裕がなければ他のドライブに変えるなどしてください.
			</div>
	
			その他特に弄る必要はないのでこの指定を終えたら「Continue」を押します.
			</li>
			
			<li>するとC:\MinGW配下へファイル群が自動でダウンロードされます.
			ここでダウンロードされるのはMinGW本体ではなくそのインストーラであり、合計サイズにしておよそ2MBほどです.
			100%と表示されたらダウンロードが終わったということです.　「Continue」を押して次へ進みます.
			ここでうっかり間違って「Quit」を押すとウィンドウが閉じてしまいますが…
			
			<b>C:\MinGW\bin\mingw-get.exeを実行すれば続きが表示されます</b>のでご安心を！
			
			この C:\MinGW\bin\mingw-get.exe こそがMinGWの本当のインストーラであり Installation Managerと呼ばれるものです.
			</li>
			
			<li>「MinGW Installation Manager」と書かれたウィンドウが表示されるのでここからインストールしたい項目を選びます.
			
			全部選んでいたらとんでもない分量になるし、その必要も全くありません.
			ここでは<b>mingw32-base</b> と <b>mingw32-g++</b>だけを選べば十分です.
			これだけでも合計180MB程度となり、実のところ結構な分量にはなります.
			
			まず左側のペインにおいて「Basic Setup」を選んだ状態にし、右側のペインで<b>mingw32-base</b>とある行の四角形のところをクリックします(あるいは右クリックでもよいです).
			このときプルダウンメニューが表示されるので「Mark for Installation」を選びます.
			四角形のところに<b>オレンジ色の矢印マーク</b>が表示されれば選択された状態になったことを意味します.
			<b>mingw32-g++</b>についても同様にして選択状態にしておきましょう.
			
			繰り返しますがこれら以外は必要ありません. 必要最小限のインストールこそ我々のモットーです.
			しかし将来その他が必要になることもあるかもしれないし…これだけで本当に大丈夫なのか？
			と心配症な方は…
			
			<b>C:\MinGW\bin\mingw-get.exeを実行すれば後からでも追加インストールできます</b>のでご安心を！
			
			この C:\MinGW\bin\mingw-get.exe こそがMinGWの本当のインストーラであり、Installation Managerと呼ばれるものです.
			(大事なことなのでもう一回書きました）.
			</li>
			
			<li>いよいよ実際のパッケージ本体をダウンロードおよびインストールします.
			一番左上にある「Installation」メニューを開き、「Apply Changes」を選びます.
			「Schedule of Pending Actions」というウィンドウが現れるので「Apply」ボタンを押せば実際にパッケージ群がずらーっとダウンロードおよびインストールされます.
			
			パッケージは勿論圧縮されてあるのでダウンロードは大して時間は掛かりません.
			ネットワークが特別混雑していないなら、筆者の貧弱な回線でも３分ほどで終る分量です.
			またインストールといってもたいしたことをしているわけではなく、C:\MinGW 配下に必要な圧縮ファイルが解凍されるだけのことです.
			上でも述べた通り、<b>mingw32-base</b> と <b>mingw32-g++</b> だけの場合、展開後は合計180MBほどになります.
			</li>
			
			<li>「Applying Scaduled Changes」というウィンドウが出て「All changes were applied successfully;」などと書いてあれば成功です.
			「Close」ボタンを押して終わりにしましょう.
			「MinGW Installation Manager」ウィンドウがまだ表示されていると思いますがこれも右上のxボタンで閉じてよいです.
			</li>
		</ol>
		
		非常に長かったですが、これにて一件落着MinGW Cコンパイラのインストール完了です.
		<a class=MstyElemLink href=#compile_by_mingw>WindowsでMinGWを使ってコンパイルする</a>の項へと進みましょう.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		補足1 : インストールされるものの内訳</b></u> 
	</div>
	<div class="message-body">
		<b>mingw32-base</b>によりインストールされるのは以下です.
		
		<ul>
		<li>コンパイラgcc(Cのみ)</li>
		<li>リンカld</li>
		<li>ライブラリアンarおよびranlib</li>
		<li>makeコマンド(MinGWではmingw32-make.exeという名前である)</li>
		<li>デバッガgdb</li>
		<li>標準Cライブラリ(このとき動的リンクされるのはデフォルトではmsvcrt.dllである)</li>
		<li>MinGW用のWindowAPI SDK</li>
		<li>リソースコンパイラwindres(iconなどの設定に利用)</li>
		<li>プロファイラgprof</li>
		<li>その他若干のGNUユーティリティ</li>
		</ul>
		
		<b>mingw32-g++</b>によりインストールされるのは以下です.
		
		<ul>
		<li>コンパイラgcc(C++用の内部コマンドg++)</li>
		<li>標準C++ライブラリ(libstdc++)</li>
		</ul>
		
		よって、もしC++は全く扱わず、つまり本当にC言語だけしか扱わないのであれば、実のところmingw32-baseだけで十分であり、つまりmingw32-g++は不要です.
		(mingw32-baseだけの場合、30MBほど節約できて全部で合計150MB程度になる).
		とはいえ、実際には C++ のコードも C と一緒くたになって巷に多く溢れかえっており、これがコンパイルできないようでは困るので今回はこれも必須項目としました.
		
		尚、gccは様々な言語のフロントエンドになっており、C++をコンパイルする際もコマンドとしてはgccコマンドを使えばよいでしょう(gccは拡張子によってCかC++かを自動的に判断します).
		ではもしmingw32-g++をインストールしていない場合に、gccからC++のコードをコンパイルしようとすると何が起こるのでしょうか？
		このときgccは以下のような非常にわかりにくいエラーメッセージを出すので注意が必要です. 
		
		<div class=MstyCode>
			gcc: error: CreateProcess: No such file or directory
		</div>
		
		もしもこれが表示されたなら mingw32-g++をインストールし忘れているか、失敗しているかしているのでもう一度mingw-get.exe(Installation Manager)を起動してこれを再インストールしましょう.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		補足2 : アンインストール、移動、バックアップ、インストール失敗時の対処方法
	</div>
	<div class="message-body">
		<b>mingw32-base</b> および <b>mingw32-g++</b> はクリーンかつハンディです.
		これのインストールにおいてはレジストリなどの書き込みなどは行われません.
		従ってアンインストールしたい場合は単にC:\MinGWをそのフォルダ毎削除すればよいです.
		
		またインストールした後、そのフォルダを丸ごと別の場所へ移動してもかまいません.
		例えばあなたの２台目のマシンにそのフォルダ毎コピーするだけで、そのマシンでも使えます.
		つまり２台目のマシン上で再び上記の手順でインストールする必要はないということです(してもよいけれども).
		
		そしてバックアップについても同様に行えます. 
		例えばMinGWが用済みになってしばらく使う予定がないので今はPCから削除したいが、今度また使うこともあるかもしれないなと思われるなら、MinGWフォルダ全体を一枚のCDに焼いておき、次回必要になった時、CD内のそのフォルダをそのまま丸ごとPCへコピーすれば即座に復元できます.
		
		ダウンロードされたアーカイブは、C:\MinGW\var\cache\mingw-get\packages内に一時保存されているので、この点が気になる方はそちらを確認されるとよいでしょう.
		インストールが完全に終った後であれば、このフォルダ内のアーカイブファイルは削除して構いません.
		(拡張子がxz、lzmaとなっているものがそれに該当する).
		
		また万一、通信の過程でこれらのアーカイブが壊れているかダウンロードが不完全であった場合は再ダウンロードが必要となりますが、その場合もこのフォルダ内の該当アーカイブを手動で消す必要があります.
		さらにその場合はデフォルトでお使いのブラウザのキャッシュも消去しておく必要があります
		( mingw-get.exeはダウンロード時、お使いのブラウザの機能を内部で利用しているためです ).
	</div>
</article>
@@.


@@L compile_by_mingw
<article class="message is-dark">
	<div class="message-header">
		必要なコマンド群
	</div>
	<div class="message-body">
		<a class=MstyElemLink href=#introduction>はじめてのコンパイル</a>では、C/C++での開発において最低限必要となる基本コマンドについて述べました.
		では、MinGW環境におけるこれらのコマンドはそれぞれ何に対応するかを以下に列挙しましょう.
		<ul>
			<li><b>Cコンパイラ</b>
			gcc
			</li>
			<li><b>C++コンパイラ</b>
			g++
			</li>
			<li><b>リンカ</b>
			ld
			</li>
			<li><b>ライブラリアン</b>
			ar および ranlib
			</li>
			<li><b>ビルドスクリプト</b>
			mingw32-make ( GNU Makefile )
			</li>
		</ul>
		即ち、これらのコマンドが実行できるように必要に応じてインストールすればよいということになります.
		これらを個別にインストールしてもよいですが、通常は MinGW が提供するインストーラーを使ってインストールすることになります.
		MinGWをまだインストールされていない方は<a class=MstyElemLink href=#get_mingw>MinGWの入手と開発環境の構築</a>を参照してください.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		Moaiのコンパイルおよびインストール
	</div>
	<div class="message-body">
		まず環境変数<b>ZNK_MINGW32_DIR</b>にMinGW32がインストールされたトップディレクトリを正しく設定します.
		次にsrcフォルダの直下にある<b>make_world.bat</b>を実行します.
		
		<div class=MstyImgBox>
			<img src=/imgs/auto_trigger_run_mingw.png />
		</div>
		
		古き良き時代を彷彿とさせるコマンドラインベースでのメニュー選択UIが表示されますので次の手順を行ってください.
		<ol>
			<li>「3. switch debug-mode」を何回か選んでDEBUG_MODEを「optimize」にします.
			</li>
			<li>「4. switch mkfid」を何回か選んでMKF_IDを「mingw」にします.
			</li>
			<li>「5. switch machine」を何回か選んでMACHINEを「x86」にします.
			</li>
			<li>「1. make install」を選びます.
			</li>
		</ol>
		ここで「選ぶ」というのは、一番先頭にある数字のキーを押せばよいです.
		またはその項目までカーソルキーで移動してEnterキーを押してもよいです.
		メニュー項目 3, 4, 5 については「選ぶ」毎にその値が循環的に変化していきます.
		
		MinGWが適切にインストールされているならば、これですべてのコンパイルが自動で行われます.
		それぞれのプロジェクトのフォルダ内にout_dirというフォルダが自動的に生成され、その中に目的の実行バイナリが生成されるはずです.
	
		<div class=box>
			尚、上記メニュー項目 5 のMACHINEで「x64」を選んだ場合は64bit版バイナリが生成されます.
			ただし mingw_x86_64_win(mingw64)をインストールし、環境変数ZNK_MINGW64_DIRを設定しておく必要があります.
			こちらは初心者の方には若干敷居が高いです.
			32bit版バイナリでも64bit Windows上で動きますから、特に拘りのない方は32bit版のバイナリで十分です.
		</div>
		さらに、srcディレクトリの一つ上の階層にmoai-v2.*-win32ディレクトリが生成され、コンパイルされた実行バイナリや設定ファイルなどの必要なものすべてが、そのディレクトリへとインストールされます.
	
		<div class=box>
			なんらかの理由でこのインストール処理だけを省略し、つまり純粋にコンパイルだけを行いたい場合は、「1. make install」の替わりに「0. make」を選んでください.
		</div>
		以上でWindows版のMoaiのコンパイルとインストールはすべて完了です.
		お疲れ様でした.
	</div>
</article>
@@.


@@L compile_by_vc
以下ではVC(Visual C++)でのコンパイル方法について説明します.
VCは既にお使いのPCにインストールされているものと仮定して話を進めます.

Moaiのコンパイルはすべてコマンドラインベースで行われます.
IDEを起動する必要はありません.

<article class="message is-dark">
	<div class="message-header">
		VCでコマンドラインよりコンパイルする場合に関する基礎知識
	</div>
	<div class="message-body">

		VCの場合、内部的にはnmakeコマンドがMakefile_vc.makを実行することでビルドが行われます.
		その際、いくつかの必要な環境変数をあらかじめ設定しておく必要があります.
		通常、これらを手動で設定する必要はなく、替わりに変数設定用バッチファイルを実行させます.
	
		この変数設定用バッチファイルはVCのインストールディレクトリ配下に存在するのですが、厄介なことにVCのバージョンやマシン環境によってそのありかやファイル名が異なるのです.
		例えばVC11.0のx86環境向けなら、これはvsvars32.bat という名前になっており、

		<div class=MstyCode>
			C:\Program Files (x86)\Microsoft Visual Studio 11.0\Common7\Tools
		</div>

		などといったフォルダ内に存在します. あるいは

		<div class=MstyCode>
			C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\bin
		</div>

		などといったフォルダ内に同様の(しかし名前は異なる)ファイルが存在することもあります.
		またx64環境(VCではamd64やx86_amd64などと表記されます)向けの場合、詳細は省略しますが状況はさらに複雑です.
	</div>
</article>


<article class="message is-dark">
	<div class="message-header">
		必要なコマンド群
	</div>
	<div class="message-body">
		<a class=MstyElemLink href=#introduction>はじめてのコンパイル</a>では、C/C++での開発において最低限必要となる基本コマンドについて述べました.
		では、VC環境におけるこれらのコマンドはそれぞれ何に対応するかを以下に列挙しましょう.
		<ul>
			<li><b>Cコンパイラ</b>
			cl
			</li>
			<li><b>C++コンパイラ</b>
			cl
			</li>
			<li><b>リンカ</b>
			link
			</li>
			<li><b>ライブラリアン</b>
			lib
			</li>
			<li><b>ビルドスクリプト</b>
			nmake
			</li>
		</ul>
		これらのコマンドはVCをインストールすれば付属しています.
		さらに上述した環境変数設定用バッチファイルを実行させれば、これらのコマンドの存在するディレクトリへのPATHが設定されます.
		これでコマンドラインからこれらのコマンドが普通に使えるようになります.
	</div>
</article>


<article class="message is-dark">
	<div class="message-header">
		Moaiのコンパイルおよびインストール
	</div>
	<div class="message-body">
		Moaiでは、通常は以下で述べる手順に従うことによりコンパイルを簡単に行うことが可能です.
		特にVC6.0以上VC14.0以下のx86環境向けならこれはうまく機能すると思います.
	
		しかし上で挙げたVCのバージョン以外では、この手順は失敗するかもしれません.
		その場合は、以下のNoteで述べます特別な環境変数をまずは明示的に指定した上で再度この手順をお試しください.
		
		では手順の説明に入ります.
		まずsrcフォルダの直下にある<b>make_world.bat</b>を実行します.
		
		<div class=MstyImgBox>
			<img src=/imgs/auto_trigger_run_vc.png />
		</div>
		
		古き良き時代を彷彿とさせるコマンドラインベースでのメニュー選択UIが表示されますので次の手順を行ってください.
		<ol>
			<li>「3. switch debug-mode」を何回か選んでDEBUG_MODEを「optimize」にします.
			</li>
			<li>「4. switch mkfid」を何回か選んでMKF_IDを「vc」にします.
			</li>
			<li>「5. switch machine」を何回か選んでMACHINEを「x86」あるいは「x64」にします.
			</li>
			<li>「1. make install」を選びます.
			</li>
		</ol>
		
		<div class=box>
			ここで「選ぶ」というのは、一番先頭にある数字のキーを押せばよいです.
			またはその項目までカーソルキーで移動してEnterキーを押してもよいです.
			メニュー項目 3, 4, 5 については「選ぶ」毎にその値が循環的に変化していきます.
		</div>
		VCが適切にインストールされているならば、これですべてのコンパイルが自動で行われます.
		それぞれのプロジェクトのフォルダ内にout_dirというフォルダが自動的に生成され、
		その中に目的の実行バイナリが生成されるはずです.
		
		<div class=box>
			尚、上記メニュー項目 5 のMACHINEで「x64」を選んだ場合は64bit版バイナリが生成されます.
			ただし VCのバージョンによっては64bit用のコンパイルが可能なように色々と設定しておく必要があるかもしれません.
			こちらは初心者の方には若干敷居が高いです.
			32bit版バイナリでも64bit Windows上で動きますから、特に拘りのない方は32bit版のバイナリで十分です.
		</div>
		さらに、srcディレクトリの一つ上の階層にmoai-v2.0-win32ディレクトリが生成され、
		コンパイルされた実行バイナリや設定ファイルなどの必要なものすべてが、そのディレクトリへとインストールされます.
		(なんらかの理由でこのインストール処理だけを省略したい、つまり純粋にコンパイルだけを行いたい場合は、
		「1. make install」の替わりに「0. make」を選んでください)
		
		以上でWindows版のMoaiのコンパイルとインストールはすべて完了です.
		お疲れ様でした.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		上記の手順で失敗する場合のトラブルシューティング
	</div>
	<div class="message-body">
		Moaiのビルドシステムは、あなたのPCにインストールされているVCを自動的に認識します.
		内部的にはこの自動認識は src\bat_utils\setenv_vc.bat というバッチファイルにおいて行われます.
		上記の手順で失敗する場合、この自動認識が失敗していると考えられます.

		VCがインストールされている場合、VS??COMNTOOLS (??にはVCの内部バージョン番号が入る)という形式の名前の環境変数が設定されているはずです.
		これは例えばVisual Studio 2012の場合ですと、( 2012ではVCの内部バージョンは11.0になりますので )環境変数名は VS110COMNTOOLS であり、その値は

		<div class=MstyCode>
			C:\Program Files (x86)\Microsoft Visual Studio 11.0\Common7\Tools
		</div>

		などとなっています. これによりVCのインストールフォルダのパスが明らかとなるわけです.
		また、上記のNote「VCでのコンパイルに関する一般知識」でも述べましたが、このフォルダにはVCにおける変数設定用バッチファイルも存在します.
	</div>
</article>

では次にMoaiのビルドシステムで用意されている環境変数について説明します.
未知のバージョンのVCなどで上記の自動認識に失敗する場合でも、これらの環境変数をうまく指定することにより、Moaiのビルドシステムでのコンパイルが可能となります.

<article class="message is-dark">
	<div class="message-header">
		環境変数 ZNK_VSCOMNTOOLS
	</div>
	<div class="message-body">
		この環境変数が明示的に指定されている場合、src\bat_utils\setenv_vc.batは上記で述べた環境変数 VS??COMNTOOLS を参照する替わりにこのZNK_VSCOMNTOOLSの指定値を使います.

		src\bat_utils\setenv_vc.batは、この環境変数値が示すフォルダの配下に、さらに以下のbatファイル群が存在するかどうかを調査します.
		もしも存在するならそれを採用して実行するという流れになります.
		<ul>
			<li>vsvars32.bat</li>
			<li>vsvars64.bat</li>
			<li>vsvarsamd64.bat</li>
			<li>..\..\VC\bin\vcvars64.bat</li>
			<li>..\..\VC\bin\amd64\vcvarsamd64.bat</li>
			<li>..\..\VC\bin\x86_amd64\vcvarsx86_amd64.bat</li>
			<li>VsDevCmd.bat</li>
		</ul>
		よってお使いのVCにおいて上記のbatファイルの存在するフォルダの位置がわかれば、ZNK_VSCOMNTOOLSにそのフォルダのフルパスを指定すればよいことになります.

		一つ注意点があります.
		例えば「Program Files」のように途中で半角スペースが入るフォルダ名の場合でもZNK_VSCOMNTOOLSで指定する文字列はダブルクォートで括らないようにして設定してください.
		その理由は src\bat_utils\setenv_vc.bat の内部でZNK_VSCOMNTOOLSをダブルクォートで括って扱っているためです.
		このときバッチファイルの文法に起因して二重にダブルクォートで括ってしまう状況が発生してしまい、これによりうまく機能しません.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		環境変数 ZNK_VC_SETENV32_CMD と ZNK_VC_SETENV32_ARGS
	</div>
	<div class="message-body">
		環境変数ZNK_VC_SETENV32_CMDが明示的に指定されている場合、src\bat_utils\setenv_vc.batはその指定値をx86向け変数設定用バッチファイルのありか(フルパス)とみなします.
		例えばVC11の場合ですと

		<div class=MstyCode>
			C:\Program Files (x86)\Microsoft Visual Studio 11.0\Common7\Tools\vsvars32.bat
		</div>

		などといった値が考えられます(VC11の場合はこの値を明示的に指定する必要はないとは思いますが).
		さらにこのバッチファイルになんらかのオプション引数を与えたいとします.
		その場合は、環境変数 ZNK_VC_SETENV32_ARGSにそのオプション引数を指定します.

		ZNK_VSCOMNTOOLSのときと同様の注意点があります.
		途中で半角スペースが入る場合などであっても、指定する文字列はダブルクォートで括らないようにしてください.
		尚、この環境変数とZNK_VSCOMNTOOLSを両方設定した場合は、ZNK_VSCOMNTOOLSの値よりこの環境変数の値の方が優先されます.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		環境変数 ZNK_VC_SETENV64_CMD と ZNK_VC_SETENV64_ARGS
	</div>
	<div class="message-body">
		環境変数ZNK_VC_SETENV64_CMDが明示的に指定されている場合、src\bat_utils\setenv_vc.batはその指定値をx64向け変数設定用バッチファイルのありか(フルパス)とみなします.
		例えばVC11の場合ですと

		<div class=MstyCode>
			C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\bin\x86_amd64\vsvarsx86_amd64.bat
		</div>

		などといった値が考えられます(VC11の場合はこの値を明示的に指定する必要はないとは思いますが).
		さらにこのバッチファイルになんらかのオプション引数を与えたいとします.
		その場合は、環境変数 ZNK_VC_SETENV64_ARGSにそのオプション引数を指定します.

		ZNK_VSCOMNTOOLSのときと同様の注意点があります.
		途中で半角スペースが入る場合などであっても、指定する文字列はダブルクォートで括らないようにしてください.
		尚、この環境変数とZNK_VSCOMNTOOLSを両方設定した場合は、ZNK_VSCOMNTOOLSの値より
		この環境変数の値の方が優先されます.
	</div>
</article>
@@.


@@L compile_on_cygwin
既にCygwinを愛用されており、MinGWなどの競合開発環境をわざわざインストールしたくない方もおられると思います.
この項目はそのような方向けです.

<div class=box>
	<u><b>注意</b></u>
	
	Cygwinではややこしいことに、この上で動作するMinGWをインストールすることもできます.
	その場合gccオプションとして -mno-cygwinを使うことで(Cygwin版gccではなく)MinGW版gccを呼び出すこともできます.
	ここではムダにややこしくしたくないため、そのような使い方については対応しません.
	つまり作成を目指す実行バイナリは純粋なWindows APIをベースとしたプログラムではなく、cygwin1.dllなどのCygwin固有のdllをベースとしたUNIXエミュレーションで動作するプログラムとします.
	(Cygwin本来の趣旨は後者でしょう).
	
	MinGWでWindows純正のプログラムとしてコンパイルしたい場合は、上記<a class=MstyElemLink href=#compile_by_mingw>WindowsでMinGWを使ってコンパイルする</a>を参照して下さい.

	あるいはMSYSを使うという手もあります.
	下記<a class=MstyElemLink href=#compile_on_msys>MSYSを使ってコンパイルする</a>を参照して下さい.

	どうしてもCygwin上でMinGWを使いたい方は MSYS の状況に一番近いことから考えて、Makefile_msys.makを各自修正するのが一番簡単であると思います.
	生成されるdll名の微調整やコマンドラインオプション -mno-cygwin を追加する程度の変更で済むと思います.
</div>

<article class="message is-dark">
	<div class="message-header">
		必要なコマンド群
	</div>
	<div class="message-body">
		<a class=MstyElemLink href=#introduction>はじめてのコンパイル</a>では、C/C++での開発において最低限必要となる基本コマンドについて述べました.
		では、Cygwin環境におけるこれらのコマンドはそれぞれ何に対応するかを以下に列挙しましょう.
		<ul>
			<li><b>Cコンパイラ</b>
			gcc
			</li>
			<li><b>C++コンパイラ</b>
			g++
			</li>
			<li><b>リンカ</b>
			ld
			</li>
			<li><b>ライブラリアン</b>
			ar および ranlib
			</li>
			<li><b>ビルドスクリプト</b>
			make (GNU Makefile)
			</li>
		</ul>
		Cygwinインストーラ(setup-x86.exe)では、gcc-core, gcc-g++, make, binutilsをインストールしておきます.
		( binutilsとは、ld, ar, ranlib, asコマンドなどを含むパッケージです ).
		setup-x86.exe においてこれらを個別にインストールしてもよいですが、Develカテゴリにこれらは全て含まれているので面倒ならこのカテゴリごと一括でインストールしてもよいです.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		Moaiのコンパイルおよびインストール
	</div>
	<div class="message-body">
		Cygwinターミナルを開き、srcディレクトリ内の以下のシェルスクリプトを実行します.
		
		<div class=box><div class=MstyCode>
			sh ./make_world.sh install
		</div></div>
		
		上記の基本コマンドが適切にインストールされているならば、これですべてのコンパイルが自動で行われます.
		
		<div class=box>
			このシェルスクリプトにより、Makefile_cygwin.mak の存在する各ディレクトリへ自動的に移動しつつmake -f Makefile_cygwin.mak が実行されます.
			コンパイル後の実行バイナリは各ディレクトリ内のout_dirに格納されます.
		</div>
		
		尚、Cygwinの場合、出来上がるdllの名前にはcygプリフィックスをつける仕様としてあります.
		これは別に必須というわけではないのですが、Cygwin用のdllはVCやMinGWにより生成する普通のdllとは一部異なるため、区別するためにこのようにしてあります. 
		
		さらに、srcディレクトリの一つ上の階層にmoai-v2.*-cygwin32ディレクトリが生成され、コンパイルされた実行バイナリや設定ファイルなどの必要なものすべてが、そのディレクトリへとインストールされます.
		(なんらかの理由でこのインストール処理だけを省略し、つまり純粋にコンパイルだけを行いたい場合は、「sh ./make_world.sh install」の替わりに「sh ./make_world.sh」と実行してください)
		
		以上でMoaiのコンパイルとインストールはすべて完了です.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		動作確認
	</div>
	<div class="message-body">
		念のため、コンパイルおよびインストールされたmoaiが起動するか確認しておきましょう.
		srcディレクトリを出てmoai-v2.*-cygwin32ディレクトリへと移動し、moaiを起動します.
		以下のようなメッセージが表示されればmoaiは無事起動しています.
		
		<div class=box><div class=MstyCode>
			Moai : config load OK.
			Moai : target load OK.
			Moai : analysis load OK.
			Moai : Filter Loading [filters/….myf]
			Moai : Plugin Loading [plugins/….so]
			…
			Moai : acceptable_host=[LOOPBACK]
			Moai : blocking_mode=[0]
			Moai : AutoGet PrivateIP=[192.168.…].
			Moai : Listen port 8124...
			
			Moai : ObserveR : 1-th sock events by select.
		</div></div>
	</div>
</article>
@@.


@@L compile_on_msys
ここではMSYS1.0を使用したMinGWによるコンパイル手順を示します.
申し訳ありませんがMSYS2.0の場合は解説いたしません.

<article class="message is-dark">
	<div class="message-header">
		必要なコマンド群
	</div>
	<div class="message-body">
		<a class=MstyElemLink href=#introduction>はじめてのコンパイル</a>では、C/C++での開発において最低限必要となる基本コマンドについて述べました.
		では、MSYS環境におけるこれらのコマンドはそれぞれ何に対応するかを以下に列挙しましょう.
		<ul>
			<li><b>Cコンパイラ</b>
			gcc
			</li>
			<li><b>C++コンパイラ</b>
			g++
			</li>
			<li><b>リンカ</b>
			ld
			</li>
			<li><b>ライブラリアン</b>
			ar および ranlib
			</li>
			<li><b>ビルドスクリプト</b>
			mingw32-make (GNU Makefile)
			</li>
		</ul>
		というかそもそもMSYSとはMinGWと組み合わせて使うものですから、これらは当然ながらMinGWといっしょです.
		そしてMinGWとMSYSをインストールしておけばこれらのコマンドも当然使えます.
		MinGWをまだインストールされていない方は、まずは<a class=MstyElemLink href=#get_mingw>MinGWの入手と開発環境の構築</a>を先にご一読下さい.
		MSYSのインストール方法については以下で詳しく述べます.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		MSYSのインストール
	</div>
	<div class="message-body">
		この手順では、MinGWのインストールは既に完了しているものとして話をすすめます.
		MinGWのインストールについては<a class=MstyElemLink href=#get_mingw>MinGWの入手と開発環境の構築</a>で解説いたしました.
		既にそちらをご一読されている方はもうお分かりですね？
	
		<b>C:\MinGW\bin\mingw-get.exeを実行すれば後からでも追加インストールできます</b>のでご安心をいただけるのでした.
		この C:\MinGW\bin\mingw-get.exe こそがMinGWの本当のインストーラであり、Installation Managerと呼ばれるものであるッ！のでした.
	
		実はこのInstallation ManagerからMSYS1.0も追加インストールできます.
		というわけで、まずはこれを起動するため mingw-get.exe を実行しましょう.
		次に具体的な手順を以下に示します.
		<ol>
			<li>「MinGW Installation Manager」と書かれたウィンドウが表示されるのでここからインストールしたい項目を選びます.
			まず左側のペインにおいて「Basic Setup」を選んだ状態にし、右側のペインで<b>msys-base</b>とある行の四角形のところをクリックします(あるいは右クリックでもよいです).
			このときプルダウンメニューが表示されるので「Mark for Installation」を選びます.
			四角形のところに<b>オレンジ色の矢印マーク</b>が表示されれば選択された状態になったことを意味します.
			</li>
			
			<li>いよいよ実際のパッケージ本体をダウンロードおよびインストールします.
			一番左上にある「Installation」メニューを開き、「Apply Changes」を選びます.
			「Schedule of Pending Actions」というウィンドウが現れるので「Apply」ボタンを押せば実際にパッケージ群がずらーっとダウンロードおよびインストールされます.
			
			パッケージは勿論圧縮されてあるのでダウンロードは大して時間は掛かりません.
			またインストールといってもたいしたことをしているわけではなく、C:\MinGW配下に必要な圧縮ファイルが解凍されるだけのことです.
			<b>msys-base</b> だけの場合、展開後は合計20MBほどになります.
			</li>
			
			<li>「Applying Scaduled Changes」というウィンドウが出て「All changes were applied successfully;」などと書いてあれば成功です. 「Close」ボタンを押してこれを閉じましょう.
			「MinGW Installation Manager」ウィンドウがまだ表示されていると思いますがこれも右上のxボタンで閉じてよいです.
			</li>
			
			<li>C:\MinGWフォルダを開いてみます.
			<b>msys\1.0</b>というフォルダが新しく出来ているはずであり、これがMSYSの本体です.
			この中に入るとmsys.batというファイルがあるのがわかります.
			これをクリックして実行するとMSYSのターミナルウィンドウが開きます.
			毎回このフォルダまで入ってこれをクリックするのが面倒なら、デスクトップにこのmsys.batへのショートカットを作っておくとよいでしょう.
			
			プロンプトの部分に「/home/あなたのユーザ名」のような表示がなされているはずです.
			これはカレントディレクトリを示していますが、これは一体どこなのでしょうか？
			</li>
			
			<li><b>我々が最初に打つべきコマンドは mount です</b>.
			現在どのWindows上のどのフォルダが、MSYS内のどのディレクトリにマウントされているのか？
			mountコマンドを打つことでこれを確認できます.
			では早速確認してみましょう.
			
			<div class=box><div class=MstyCode>
				$ mount
				C:\MinGW\msys\1.0 on /usr   type user (binmode,noumount)
				C:\MinGW\msys\1.0 on /      type user (binmode,noumount)
				C:\MinGW\msys\1.0 on /mingw type user (binmode)
				C:\Users\Zenkaku\AppData\Local\Temp on /tmp type user (binmode,noumount)
				c: on /c type user (binmode,noumount)
			</div></div>
			
			上記より、ルートディレクトリ(/)はC:\MinGW\msys\1.0であることがわかりますね.
			つまりMSYS上で例えば「/home/Zenkaku」となっていれば、その実体は「C:\MinGW\msys\1.0\home\Zenkaku」フォルダということです.
			</li>
			
			<li>次にmakeコマンドが使えるかどうかを確認します.
			
			<div class=box><div class=MstyCode>
				$ make
				make: *** No targets specified and no makefile found.  Stop.
			</div></div>
			
			無事上記のような表示になれば、MSYSはmakeコマンドを認識しています.
			whichコマンドを使えば、make.exeの実体は「C:\MinGW\msys\1.0\bin\make.exe」ということもわかります.
			
			<div class=box>
				万一 sh: make command not found などと表示されたら、何らかの理由でmake.exe がきちんとインストールされていないということです.
				念のため、上記に戻って「MinGW Installation Manager」からmsys-baseをインストールしなおした方がよいでしょう.
				
				また左ペインにおいて「All Packages」⇒「MSYS」⇒「MSYS Base System」を選ぶとmsys-make がインストールされているかどうかをピンポイントで確認することもできます.
				万一これがインストール状態になっているにも関わらずこの症状が出るなら、おそらくは「C:\MinGW\var\cache\mingw-get\packages\make-3.81-3-msys-1.0.13-bin.tar.lzma」が壊れています.
				(あなたの環境ではこのファイル名は若干異なるかもしれません).
				まずはこのファイルを削除し、さらにあなたが普段使っているブラウザのキャッシュを消した上で再度インストールを試みた方がいいでしょう.
			</div>
			</li>
			
			<li>次にgccコマンドが使えるかどうかを確認します.
			
			<div class=box><div class=MstyCode>
				$ gcc
				sh: gcc: command not found
			</div></div>
			
			無事上記のような表示になれば…、いや無事ではないですね！
			MSYSはgccコマンドを認識していません！ なぜでしょうか？
			
			我々は既にMinGW本体をインストールしています. そして gcc.exe の実体はC:\MinGW\bin配下にあるはずです.
			つまりこの位置をMSYSに教えねばならないということです.
			そのためにはMinGWのトップフォルダ C:\MinGW をMSYSでの /mingw ディレクトリとして<b>マウント</b>させなければなりません.
			
			C:\MinGW\msys\1.0\etc\fstab.conf をテキストエディタで開きます.
			もしもこれが存在しなければ、まず同フォルダ内の fstab.sample を fstab.conf と言う名前でコピーしてそれを開きます.
			このファイルでは # で始まる行は単なる説明文なので無視してよく、それ以外の行に注目しましょう.
			次のような行があると思います.
			
			<div class=box><div class=MstyCode>
				c:/mingw	/mingw
			</div></div>
			
			二つ値がありますね.
			左側が Windows での実体をあらわすパス、右側がその MSYS 上でのディレクトリを示します.
			今回は /mingw に相当する実体をあらわすパスを設定したいのですから、我々が確認すべきはこの左側です.
			もしもあなたの MinGW がインストールされたフォルダが C:\MinGW ではないなら、上記の左側( c:/mingw の部分 )をあなたのMinGWがインストールされたフォルダのパスへ正しく書き換える必要があります( C:\MinGW なら何も修正する必要はありません ).
			書き換えたらこのファイルを上書き保存しましょう.
			</li>
			
			<li>再度gccコマンドが使えるかどうかを確認します.
			
			<div class=box><div class=MstyCode>
				$ gcc
				sh: gcc: command not found
			</div></div>
			
			無事に sh: gcc: command not found と表示されたでしょうか？
			そう！まだダメです！なぜでしょうか？
			
			実は我々はまだ最後の仕上げを一つ忘れているのでした.
			<b>我々が最後に打つべきコマンドは mount です</b>.
			上記の /etc/fstab.conf に書かれた内容を反映させるには、次のようにしてmountコマンドを実行する必要があります.
			
			<div class=box><div class=MstyCode>
				$ mount /mingw
			</div>
			
			万一 '/mingw' is already mounted などと表示されたら、一旦/mingwをアンマウントしてから、再度マウントする必要があります. 次のようになるでしょう.
			
			<div class=box><div class=MstyCode>
				$ umount /mingw
				$ mount /mingw
			</div></div>
			
			将来、MinGWフォルダの位置を移動するなどして /etc/fstab.confの内容を書き直したらこのアンマウント/マウントを再度実行する必要があるので注意しましょう.
			
			今度こそ gcc が無事起動できるようになったはずです.
			gcc と単独で実行したとき、「no input files」などと表示されればOKです.
			</li>
		</ol>
		非常に長かったですが、これにて一件落着インストール完了です.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		Moaiのコンパイルおよびインストール
	</div>
	<div class="message-body">
		MSYSターミナルを開き、srcディレクトリ内の以下のシェルスクリプトを実行します.
		
		<div class=box><div class=MstyCode>
			sh ./make_world.sh install
		</div></div>
		
		上記の基本コマンドが適切にインストールされているならば、これですべてのコンパイルが自動で行われます.
		
		<div class=box>
			このシェルスクリプトにより、Makefile_msys.mak の存在する各ディレクトリへ自動的に移動しつつ make -f Makefile_msys.mak が実行されます.
			コンパイル後の実行バイナリは各ディレクトリ内のout_dirに格納されます.
		</div>
		
		さらに、srcディレクトリの一つ上の階層にmoai-v2.0-win32ディレクトリが生成され、
		コンパイルされた実行バイナリや設定ファイルなどの必要なものすべてが、そのディレクトリへとインストールされます.

		<div class=box>
			なんらかの理由でこのインストール処理だけを省略し、つまり純粋にコンパイルだけを行いたい場合は、「sh ./make_world.sh install」の替わりに「sh ./make_world.sh」と実行してください.
		</div>
		以上でMoaiのコンパイルとインストールはすべて完了です.
		moai-v2.0-win32 フォルダを開き、moai.exeが起動できるかどうかを確認しましょう.
	</div>
</article>
@@.


@@L compile_on_others_windows
軍曹…キミが(MinGWでもVCでもCygwinでもなく)あえてこれらを選ぶというなら、我々もそれを支援すべくそのヒントをここで示そう.
尚ここでの説明ではイチイチ丁寧語は使わないぞ？

こんなの選ぶくらいだ.
今更基本知識の説明はいらんな？

こんな変態御用達なmakefileまで用意してはかさばるのでソースコードに同梱はしていない.
だが実のところlibZnkやMoaiのソースコード自体はこれらでもコンパイルできるように移植性に一応配慮してある.
興味がある<b>変態野郎な方</b>は、以下を参考に各自Makefileを作れ.

<article class="message is-dark">
	<div class="message-header">
		BCC5.5(Borland C++ Compiler 5.5) における必要なコマンド群
	</div>
	<div class="message-body">
		こんなの選ぶくらいだ.
		知ってると思うが一応書いとくぞ？
		<ul>
			<li><b>Cコンパイラ</b>
			bcc32
			</li>
			<li><b>C++コンパイラ</b>
			bcc32
			</li>
			<li><b>リンカ</b>
			ilink32
			</li>
			<li><b>ライブラリアン</b>
			tlib
			</li>
			<li><b>ビルドスクリプト</b>
			一応BCCに付属しているmakeコマンドがあるにはある.
			VCのnmakeと互換であるようだが、微妙に完全互換ではない.
			これではなく GNU Makefile を使うことを強くお勧めしておく.
			</li>
		</ul>
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		BCC5.5(Borland C++ Compiler 5.5) におけるコンパイルとそのオプション指定
	</div>
	<div class="message-body">
		<ul>
			<li><b>objを作る場合の指定方法</b>
			これは何てことはない至って普通な感じだ.
			<div class=box><div class=MstyCode>
				bcc32 -w -RT -c -oYourFile.obj YouFile.c
			</div></div>
			</li>

			<li><b>exeを作る場合の指定方法</b>
			OBJSは、+記号で各objファイルを連結したものを指定するという変態仕様である.
			<div class=box><div class=MstyCode>
				ilink32 -w -Gn -C -Tpe -ap c0x32.obj $(OBJS) $(LFLAGS),YourApplication.exe,,import32.lib cw32mt.lib,,YourResource.res
			</div></div>
			</li>
		
			<li><b>静的ライブラリ(lib)を作る場合の指定方法</b>
			オプション /P4096 はページサイズとなり、OMF形式ではこれを明示的に指定する必要がある.
			<div class=box><div class=MstyCode>
				tlib YourStaticLib.lib /P4096 $(OBJS)
			</div></div>
			</li>

			<li><b>dllおよびそれに対応するインポートライブラリを作る場合の指定方法</b>
			インポートライブラリはimplibを使用してdllあるいはdefファイルから自動生成する.
			尚、この方法は__stdcallには対応しない.
			<div class=box><div class=MstyCode>
				ilink32 -w -Gn -C -Tpd c0d32x.obj $(OBJS) $(LFLAGS),YourDLL.dll,,import32.lib cw32mt.lib,YourDLL.def
				implib -f -a YourDLL.lib YourDLL.dll
				( あるいは implib -f -a YourDLL.lib YourDLL.def )
			</div></div>
			</li>
		</ul>
	</div>
</article>
		
<article class="message is-dark">
	<div class="message-header">
		DMC(Digital Mars C/C++) における必要なコマンド群
	</div>
	<div class="message-body">
		こんなの選ぶくらいだ.
		知ってると思うが一応書いとくぞ？
		<ul>
			<li><b>Cコンパイラ</b>
			dmc
			</li>
			<li><b>C++コンパイラ</b>
			dmc
			</li>
			<li><b>リンカ</b>
			link
			</li>
			<li><b>ライブラリアン</b>
			lib
			</li>
			<li><b>ビルドスクリプト</b>
			一応DMCに付属しているmakeコマンドがあるにはある.
			だがアレは腐っているッ！
			GNU Makefile を使うことを強くお勧めしておく.
			</li>
		</ul>
	</div>
</article>
		
<article class="message is-dark">
	<div class="message-header">
		DMC(Digital Mars C/C++) におけるコンパイルとそのオプション指定
	</div>
	<div class="message-body">
		我々が実際にテストしたのは最新バージョン(Ver8.57)のみである.
		<ul>
			<li><b>objを作る場合の指定方法</b>
			イキナリ吐きそうなほどのオプション指定の応酬である.
			<div class=box><div class=MstyCode>
				dmc -HP99 -Bj -j0 -Ab -Ae -Ar -w6 -c -oYourFile.obj YouFile.c
			</div></div>
			</li>
			
			<li><b>exeを作る場合の指定方法</b>
			カンマがウザいあたりはBCCと同じだ.
			<div class=box><div class=MstyCode>
				link -EXET:NT $(OBJS),YourApplication.exe,,ws2_32.lib user32.lib kernel32.lib,,YourResource.res
			</div></div>
			</li>
			
			<li><b>静的ライブラリ(lib)を作る場合の指定方法</b>
			オプション -p4096 はページサイズとなり、OMF形式ではこれを明示的に指定する必要がある.
			<div class=box><div class=MstyCode>
				lib -c -p4096 YourStaticLib.lib $(OBJS)
			</div></div>
			</li>
			
			<li><b>dllおよびそれに対応するインポートライブラリを作る場合の指定方法</b>
			インポートライブラリはimplibを使用してdllから自動生成する.
			<div class=box><div class=MstyCode>
				link -EXET:NT $(OBJS),YourDLL.dll,,ws2_32.lib user32.lib kernel32.lib,YourDLL.def
				implib /system YourDLL.lib YourDLL.dll
			</div></div>
			</li>
		</ul>
	</div>
</article>
@@.


@@L compile_on_linux
<article class="message is-dark">
	<div class="message-header">
		必要なコマンド群
	</div>
	<div class="message-body">
		<a class=MstyElemLink href=#introduction>はじめてのコンパイル</a>では、C/C++での開発において最低限必要となる基本コマンドについて述べました.
		では、Linux環境におけるこれらのコマンドはそれぞれ何に対応するかを以下に列挙しましょう.
		<ul>
			<li><b>Cコンパイラ</b>
			gcc
			</li>
			<li><b>C++コンパイラ</b>
			g++
			</li>
			<li><b>リンカ</b>
			ld
			</li>
			<li><b>ライブラリアン</b>
			ar および ranlib
			</li>
			<li><b>ビルドスクリプト</b>
			make ( GNU Makefile )
			</li>
		</ul>
		即ち、これらのコマンドが実行できるように必要に応じてインストールすればよいということになります.
		これらを個別にインストールしてもよいですが、Development系のカテゴリにある基本パッケージをインストールすればまずすべて自動でインストールされるでしょう.
		例えば Arch Linux なら pacman で base-devel をインストールする形になります. 
		具体的なインストール方法はそれぞれのLinuxディストリビューションによって千差万別なのでここでは記載しません. 
		ディストリビューションによっては最初からインストールされている可能性も高いですね.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		Moaiのコンパイルおよびインストール
	</div>
	<div class="message-body">
		上記「基本知識」で述べた必須コマンドはすべてシステムにインストールされているものとして話をすすめます.
		ターミナル(xterm, urxvtなど)を開き、srcディレクトリ内の以下のシェルスクリプトを実行します.

		<div class=box><div class=MstyCode>
			sh ./make_world.sh install
		</div></div>
	
		これですべてのコンパイルが自動で行われます.

		<div class=box>
			このシェルスクリプトにより、Makefile_linux.mak の存在する各ディレクトリへ自動的に移動しつつ <span class=MstyCodeIn>make -f Makefile_linux.mak</span> が実行されます.
			コンパイル後の実行バイナリは各ディレクトリ内のout_dirに格納されます.
		</div>
	
		尚、環境変数MACHINEに「x86」または「x64」を明示的に設定して上記を実行した場合は、それぞれ32bit版または64bit版バイナリが生成されます.
		この環境変数を指定していない場合は、Makefile_linux.mak 内で uname -m コマンドが実行され、その結果により 32bit版か64bit版かが自動的に決定されます.
		
		さらに、srcディレクトリの一つ上の階層にmoai-v2.0-linux32ディレクトリが生成され、コンパイルされた実行バイナリや設定ファイルなどの必要なものすべてが、そのディレクトリへとインストールされます.
		なんらかの理由でこのインストール処理だけを省略したい、つまり純粋にコンパイルだけを行いたい場合は、「sh ./make_world.sh install」の替わりに「sh ./make_world.sh」と実行してください.
		
		以上でMoaiのコンパイルとインストールはすべて完了です.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		動作確認
	</div>
	<div class="message-body">
		念のため、コンパイルおよびインストールされたmoaiが起動するか確認しておきましょう.
		srcディレクトリを出てmoai-v2.0-linux64ディレクトリへと移動し、moaiを起動します.
		以下のようなメッセージが表示されればmoaiは無事起動しています.
		
		<div class=box><div class=MstyCode>
			Moai : config load OK.
			Moai : target load OK.
			Moai : analysis load OK.
			Moai : Filter Loading [filters/….myf]
			Moai : Plugin Loading [plugins/….so]
			…
			Moai : acceptable_host=[LOOPBACK]
			Moai : blocking_mode=[0]
			Moai : AutoGet PrivateIP=[192.168.…].
			Moai : Listen port 8124...
			
			Moai : ObserveR : 1-th sock events by select.
		</div></div>
	</div>
</article>
@@.


@@L compile_for_android_term
Androidは基本的にLinuxですが、PC Linuxとは大きく異なる部分もあります.
そして通常、AndroidにおけるアプリはJava VMをベースとして(エントリポイントとして)提供されます.
Java VMベースなアプリでは、グラフィカルなアイコンがホーム画面に表示され、それをタップすることで起動します.

しかしながら、今回コンパイルする Moai for Android はJava VMベースではなくAndroid Terminal Emulatorの上で動作するプログラムとしてC言語で開発します.
この場合ホーム画面にMoai用の特別なアイコンが表示されることはありません.
Moaiを起動するには、まず端末エミュレータを開き、cdコマンドによりmoai実行バイナリが存在するディレクトリ(moai-v2.*-android-armeabi)へと移動してから
moai実行バイナリを直接起動する形になります.
要するにLinux環境のターミナルなどでプログラムを起動するのと同じ要領で行います.
	
<article class="message is-dark">
	<div class="message-header">
		必要なコマンド群
	</div>
	<div class="message-body">
		<a class=MstyElemLink href=#introduction>はじめてのコンパイル</a>では、C/C++での開発において最低限必要となる基本コマンドについて述べました.
		では、Android環境におけるこれらのコマンドはそれぞれ何に対応するかを以下に列挙しましょう.
		<ul>
			<li><b>Cコンパイラ</b>
			gcc
			</li>
			<li><b>C++コンパイラ</b>
			g++
			</li>
			<li><b>リンカ</b>
			ld
			</li>
			<li><b>ライブラリアン</b>
			ar および ranlib
			</li>
			<li><b>ビルドスクリプト</b>
			make ( GNU Makefile )
			</li>
		</ul>
		即ち、これらのコマンドが実行できるように必要に応じてインストールすればよいということになります.
		ただし実際に開発を行うマシンはAndroid端末ではなくPCです.
		これらのコマンド一式は<b>Android NDK</b>と呼ばれるものに含まれており、それを入手して使います.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		Android NDKの入手
	</div>
	<div class="message-body">
		<div class=box>
			この記事では、執筆時点で配布されているr14を例にとります.
			あなたが入手するAndroid NDK最新バージョンでは、仕様が変わっている可能性もあることをご了承下さい.
		</div>
		
		Android NDKは <a class=MstyWrapLink href=https://developer.android.com/ndk/downloads/index.html target=_blank>http://developer.android.com/ndk/downloads/index.html</a>よりダウンロードできます.
		また開発はAndroid上では行えないためPCが必要です.
		つまり Android NDK をあなたの開発用PCへダウンロードし、このPC上にて開発を行う形になります.
		
		Android NDK のファイルサイズはかなり大きいので注意して下さい.
		ダウンロードするzipファイルは約750MB程度もあり、さらにこれを解凍展開するとなんと<b>3GB</b>ほどにもなります！
		つまりこれらを単純に合計しただけでもディスクの空きが4GB程度必要となります.
		
		<div class=box>
			このターミナルエミュレーション上で動作するAndroid版Moaiについては、Android Studio および android-sdk は<b>必要ありません</b>.
			インストールさえも不要です. 同様にJDK(Java Development Kit)やJREなども<b>必要ありません</b>.
		</div>
		
		Android NDKをダウンロードしたら、これをディスクへ解凍展開します. 無事解凍できたでしょうか？
		なにせファイルサイズが馬鹿デカイため、下手すると解凍ツールの実行段階でさえエラーを起こし兼ねません.
		念のためエラー表示等が出ていないかを確認しましょう.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		Moaiのコンパイルおよびインストール
	</div>
	<div class="message-body">
		さて、いよいよAndroid NDKを利用したコンパイル作業に入ります. ここではWindows上でコンパイルする場合について述べます.
		LinuxあるいはCygwin上で行う場合については後述の「ndk-buildコマンドを用いてコンパイルする方法」を参照して下さい.
		ただし、Moai Ver2.0 ではこのndk-buildを用いたコンパイルは推奨しません.
		
		まず環境変数<b>ZNK_NDK_DIR</b>にAndroid NDKのトップディレクトリを正しく設定します.
		次にsrcフォルダの直下にある<b>make_world.bat</b>を実行します.
		
		<div class=MstyImgBox>
			<img src=/imgs/auto_trigger_run_mingw.png />
		</div>

		古き良き時代を彷彿とさせるコマンドラインベースでのメニュー選択UIが表示されますので次の手順を行ってください.
		<ol>
			<li>「3. switch debug-mode」を何回か選んでDEBUG_MODEを「optimize」にします.
			</li>
			<li>「4. switch mkfid」を何回か選んでMKF_IDを「android」にします.
			</li>
			<li>「5. switch machine」を何回か選んでMACHINEを「armeabi」にします.
			</li>
			<li>「1. make install」を選びます.
			</li>
		</ol>
		ここで「選ぶ」というのは、一番先頭にある数字のキーを押せばよいです.
		またはその項目までカーソルキーで移動してEnterキーを押してもよいです.
		メニュー項目 3, 4, 5 については「選ぶ」毎にその値が循環的に変化していきます.
		
		Android NDKが適切にインストールされているならば、これですべてのコンパイルが自動で行われます.
		それぞれのプロジェクトのフォルダ内にout_dirというフォルダが自動的に生成され、その中に目的の実行バイナリが生成されるはずです.
		
		さらに、srcディレクトリの一つ上の階層にmoai-v2.*-android-armeabiディレクトリが生成され、
		コンパイルされた実行バイナリや設定ファイルなどの必要なものすべてが、そのディレクトリへとインストールされます.

		<div class=box>
			なんらかの理由でこのインストール処理だけを省略し、つまり純粋にコンパイルだけを行いたい場合は、「1. make install」の替わりに「0. make」を選んでください.
		</div>
		以上でAndroid版のMoaiのコンパイルとインストールは一応完了です.
	</div>
</article>
	
<article class="message is-dark">
	<div class="message-header">
		インストールディレクトリを実機へと転送
	</div>
	<div class="message-body">
		ここまででインストールは完了しましたが、これはまだPC上にあってAndroid実機にあるわけではありません.
		最後に出来上がったインストールディレクトリ moai-v2.*-android-armeabi を実機に転送しなければなりません.
		これには色々方法がありますが、とりあえずはmoai-v2.*-android-armeabiを一旦zipファイルに固めて適当なWebサイト上にアップし実機からこれをダウンロードするというクソ回りくどい方法が<s>ここで説明するには</s>一番簡単です.

		<div class=box>
			その他にも adb コマンドを利用するなどの手がありますが、その場合は別途それ用のツールなどを入手しなければなりません.
		</div>
		どんな方法でもよいですがとりあえずこれを実機へと転送して下さい.
	</div>
</article>
	
	
<article class="message is-dark">
	<div class="message-header">
		ndk-buildコマンドを用いてコンパイルする方法
	</div>
	<div class="message-body">
		Moai で提供されている Makefile_android.mak は純粋にWindows上でコンパイルするためのものです.
		即ち、このMakefile_android.mak は CygwinやLinux上においては使用できません.
		CygwinやLinux上でコンパイルするには、<b>ndk-build</b> コマンドを使用する必要があります.
		<b>ndk-build</b> コマンドは Android NDK が提供するコンパイル用スクリプトです.
		
		まずは環境変数 ZNK_NDK_DIR に Android NDK のトップディレクトリのパスをセットしましょう.
		例えば以下のような感じです.
		
		<div class=box><div class=MstyCode>
			export NK_NDK_DIR=/cygdrive/c/android-ndk-r10e
		</div></div>
		
		ndk-build コマンドの実体は $ZNK_NDK_DIR 直下、あるいは $ZNK_NDK_DIR/build ディレクトリの下にあります.
		つまり以下のように環境変数PATHをセットすれば、ndk-buildが実行できるようになるはずです.
		
		<div class=box><div class=MstyCode>
			export PATH=$PATH:$ZNK_NDK_DIR:$ZNK_NDK_DIR/build
		</div></div>
		
		各プロジェクトディレクトリに入ると mkf_android というディレクトリがあるので、さらにこの中へ移動してから ndk-build コマンドを実行するとコンパイルが始まります.
		例えばlibZnkなら、以下のようになります.
		
		<div class=box><div class=MstyCode>
			cd libZnk/mkf_android
			ndk-build
		</div></div>
		
		mkf_androidの中で ndk-buildを実行すると、同ディレクトリに libs, obj ディレクトリが生成され、コンパイルしたバイナリやライブラリなどがここに出力されます.
		ちなみに同ディレクトリ内のjniディレクトリには、ndk_-buildでコンパイルするためのMakefileが格納されてあります.
		
		尚、この方法の場合、申し訳ありませんがインストール等を自動で行う方法を現時点では提供していません.
		この方法を現バージョンでは非推奨にしている理由の一つがそれです.
		libsディレクトリ内に作成されたバイナリを手動で適切なインストール配置へコピーするというとてつもなく面倒な作業をする必要があります.
		それでも構わないという方は、公式サイトにてAndroid版のバイナリを提供しているので、それのディレクトリ構成を参考にして下さい.
		
		Moaiでは ndk-buildを使ったコンパイルのテストはあまり行っていないため、NDKのバージョンによっては上記でもうまくいかないかもしれません.
	</div>
</article>
	

<article class="message is-dark">
	<div class="message-header">
		Android Terminal Emulator上でMoaiを動作確認する
	</div>
	<div class="message-body">
		詳細については<a class=MstyElemLink target=_blank href=/moai2.0/install_android.html#ForTerm>インストール方法(Android版)</a>を参照して頂いた方がよいですが、ここでも一応簡単に説明しておきます.
		<ol>
			<li>ホームディレクトリ以外では書き込み権限および実行権限の関係で実行できないことがあります.
				よってまず「端末エミュレータ」を開き、cd コマンドよりホームディレクトリへ移動します.
				(単にcdと入力してEnterを押す).
				
				そしてmoai-v2.*-android-armeabi.zipをダウンロードなどした場合は、それは /sdcard/Download 配下に置かれています.
				これを Android Terminal Emulator のホームディレクトリへコピーしなければなりません.
				以下のように実行します.
				
				<div class=box><div class=MstyCode>
					cp /sdcard/Download/moai-v2.*-android-armeabi.zip ~/
				</div></div>
			</li>
		
			<li>moai-v2.*-android-armeabi.zip をホームディレクトリへコピーしたら、以下を実行しこれを解凍します.

				<div class=box><div class=MstyCode>
					unzip moai-v2.*-android-armeabi.zip
				</div></div>
				次に cd moai-v2.*-android-armeabi で実行バイナリのあるディレクトリ内へと移動し、moai_for_android.sh を実行します. 
				
				<div class=box><div class=MstyCode>
					sh moai_for_android.sh
				</div></div>
			</li>
		</ol>
		うまくいけばこれでMoaiが起動するはずです.
		上記「Linuxの場合」で説明したのと同様のメッセージが表示されれば成功です.
	</div>
</article>
@@.


@@L compile_for_apk
<font color=red>この記事は現在執筆中で未完成です. 完成までしばらくお待ちください.</font>

<article class="message is-dark">
	<div class="message-header">
		Introduction of Making APK
	</div>
	<div class="message-body">
		一つ前のセクションでは、ターミナルエミュレータ上で動作するandroid版実行バイナリのコンパイル方法について述べました.
		これはAndroidを非常に(その正体であり核である)Linux的に見たやり方であり、それゆえに複雑な手順が必要となったわけです.
	
		一方、通常Androidのアプリというものは apk ファイルという形をとって配布されインストールされます.
		apkファイルであれば、これをタップするだけでインストールが行えますし、インストールしたアプリはメニューやアイコンから起動することができます.
		apkファイルは、多くの場合 Google Play と呼ばれるサイトから提供されるわけですが、別にこれは必須ではありません.
		Google Play 以外のサイトからでも apk ファイルをダウンロードしてアプリをインストールすることができます.
	
		<div class=box>
			Google Play を経由して apk を配布したい場合、Googleが決めた特別な取り決めなどを色々と満たす必要があります.
			Google Play には商業的な側面もあり、そのような目的のためには考慮しなければならないことも多いのでしょう.
			しかし我々は今、Androidのアプリでお金もうけしたいわけではありませんので、ここでは Google Play は考慮しませんし、それについてこれ以上触れることもしません.
		</div>
	
		ここでは apk ファイルの作成方法と、このファイルによるandroid実機へのインストール方法について技術的な解説をします.
		ここではAndroid Studioは使用せず、最小限の構成で開発を進めます.
		必要なのはjre、gradle、android-sdk、android-ndkとなります.

		必要最小限こと我々のモットーです.
		これこそが処理の透明性です.
		ただしこれはかなり茨の道であることも付け加えておきます.
	</div>
</article>


<article class="message is-dark">
	<div class="message-header">
		JRE( Java Rutime Environment) のインストール
	</div>
	<div class="message-body">
		いわゆるJavaランタイムです.
	    以下に述べるgradleを動作するのに必要となります.
		筆者の環境は JRE Ver8.0 と比較的新しいものをインストールしています.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		gradleのインストール
	</div>
	<div class="message-body">
		gradle は androidアプリにおける java ソースのコンパイル、apkファイルの作成までを一括で行ってくれるスクリプトです.
		これらの作業に必要なファイルがない場合はそのダウンロードまで自動で行ってくれるという徹底ぶりですが、
		そのことがかえって仇となり、なんらかの問題がある場合にエラーが報告されるまで異常な時間待たされるといったようなことも起こり得ます.
		これはTry and Errorで力任せに色々試そうという戦術をとる場合かなり苦戦を強いられます.

		特にAndroid NDK と Android SDK そして gradleのバージョンにおける不整合が頻繁に起こり、(割と大きなサイズの)ダウンロードが
		勝手に裏で何度もやり直されるといった、かなり拷問に近い状況が発生します.
		それでも色々試した結果、Android NDK と Android SDK 自体のターゲットバージョンを少し古いものに想定した場合、
		どうやら最新のgradleでは問題が発生することがわかります.
		ではどのバージョンのgradleならばよいのでしょうか？

		可能なバージョンの組み合わせはかなりシビアで、ネット上に転がっているgradleのサンプルなどはほぼ全滅という惨憺たる状況です.
		（そもそもAndroid Studioを使わずに gradle と android-sdk だけでなんとかしようというのは世界的にみて少数派です.
		ましてやMoaiの場合 android-ndkもあります.)

		それでも何とかして筆者の環境では gradle-2.14.1 という一つの解(割と古いバージョンですが)にたどり着けました.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		sdk-toolsによるandroid-sdkのインストール
	</div>
	<div class="message-body">
		Android SDK はandroid アプリを生成するための主にjavaに関連したツール、API群からなります.
		ではなぜここで sdk-tools なるものが手前にワンクッションあるのかということですが、
		ターゲットとするAndroidのバージョンによって必要なファイル群が異なるためです.
		つまりまずはAndroid SDKのインストーラをインストールせよということになります.

		https://developer.android.com/studio へアクセスします.
		最後にstudioとありますが、この記事ではAndroid Studioは一切使いません.
		Android Studioのでかでかとした宣伝画像を一切無視して一番下へスクロールします.
		「Command line tools only」と書かれた部分がみつかると思います. 
		欲しいものはこれだけです. 筆者は sdk-tools として sdk-tools-windows-4333796.zip (これでも148MBもありますが)をダウンロードしました.

		ここに次にように書かれてあります.

		If you do not need Android Studio, you can download the basic Android command line tools below.
		You can use the included sdkmanager to download other SDK packages.

		sdk-tools-windows-4333796.zip 内に sdkmanager というプログラムがあり、
		これを実行することで Android SDKがダウンロード可能であると<b>一応</b>書かれてます.
		早速このzipを展開して、<s>あまり期待せず</s>sdkmanagerなるものを捜しますと、tools/bin/sdkmanager.bat というのがありました.
		batファイルですのでただちにテキストエディタで開き、内部のソースを読みます.

		JAVA_HOME環境変数にJREのインストールディレクトリを指定しなければならないことが即座にわかります.
		そしてこれを元に %JAVA_HOME%/bin/java.exe をインタプリタとして tools/lib 内にあるjarファイルを実行しているようです.

		sdkmanager.bat 内にはこれ以上の情報はありません.
		そこで次に sdkmanagerに与えるコマンドラインオプションについて知る必要があります.
		https://developer.android.com/studio/command-line/sdkmanager へアクセスします.

		これによれば、platforms-tools と 自分の望むAPIレベルのSDKツール、この二つインストールする必要があるらしいことがわかります.
		つまりこのように実行すればよいわけですね.

		sdkmanager.bat "platform-tools" "platforms;android-自分の望むAPIレベル"

		ではどのAPIレベルを選択すればよいでしょうか？
		これを決定するには、AndroidのドロドロとしたバージョンとAPIの対応の歴史を調べる必要があるわけですが…。
		紆余曲折の末、筆者の環境では android-26 に落ち着きました.

		つまりこうですね.

		sdkmanager.bat "platform-tools" "platforms;android-26"

		改めて android-sdk というフォルダを作り、これらをこの中に置きます.
		このandroid-sdkの位置を C:/share_7/AndroidSDK/android-sdk としました.
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		android-ndkのインストール
	</div>
	<div class="message-body">
		こちらはAndroid Terminal Emulator版でももうおなじみ、Android NDKです.
		Android NDK はandroid版実行バイナリを生成するためのcコンパイラやツール、ライブラリ群からなります.
		ただし今回はgradle や Android SDKなども絡んできますので油断は禁物です.
		今回筆者は android-ndk-r14b を使いました.
		android-ndkの位置は E:/share_e/trunk_id1/Android/android-ndk-r14b としました.

		またNDKにおけるplatformsについては android-14 を使う形にしました.
		(色々紛らわしいですが、このandroid-14は android-ndk-r14b のr14bとは関係ないですし、SDKのandroid-26ともはまた別のものです)
	</div>
</article>


<article class="message is-dark">
	<div class="message-header">
		apk作成のためのgradleおよびjni環境のフォルダ構成.
	</div>
	<div class="message-body">
		apk作成のためのソースプロジェクトとでも言うべき骨格であり、apk作成のための全作業はこのフォルダ内で行われます.
		[執筆中]
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		build.gradle、AndroidManifest.xml等の記述.
	</div>
	<div class="message-body">
		gradleはbuild.gradleと呼ばれるファイルの記述にしたがって実行されます.
		ちょうどmakeがMakefileを参照しながら動作するのに似ています.
		[執筆中]
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		javaソースによるActivityクラスの記述.
	</div>
	<div class="message-body">
		Activityクラスとはアプリのエントリポイントとなるjavaのクラスです.
		[執筆中]
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		cソースによるJNIインターフェースの記述.
	</div>
	<div class="message-body">
		Activityクラス内から呼び出されるCのコードです.
		ここで記述したcファイルはndk内のCコンパイラによってコンパイルされ、
		同じくndk内のリンカによって最終的にシェアードライブラリ(libmain.soファイル)となります.
		[執筆中]
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		ネイティブライブラリのリンクとAndroid.mkでの記述.
	</div>
	<div class="message-body">
		ここではlibZnkなどcで記述されたその他のライブラリをリンクする方法について述べます.
		[執筆中]
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		gradle実行によるjavaソースのコンパイルとapkファイルの生成.
	</div>
	<div class="message-body">
		上述したjavaソースをコンパイルし、生成したlibmain.so、指定したその他のライブラリ(libZnk.soなど)、
		その他リソースファイルやassetsファイルなどを統合し、最終的にapkファイルとしてまとめる処理となります.
		make_apk.batというファイルを実行します.
		[執筆中]
	</div>
</article>

<article class="message is-dark">
	<div class="message-header">
		生成したapkファイルを実機へとインストールする各種方法
	</div>
	<div class="message-body">
		adb_install_apk.batに関する解説を述べる予定.
		[執筆中]
	</div>
</article>
@@.


@@L about_libressl
	Moai システムでは HTTPS を実現するために、libressl ライブラリを使用しています.
	Moaiのソースコード内にはこの libressl のソースコードも付属しています.
	( 少し古いVCでもコンパイル可能とするため、若干コードを手直ししたものになります ).
	これに関しては以下の点に注意してください.

	<ul>
		<li>src フォルダ直下の make_world.bat または make_world.sh を初めて実行した場合、この libressl も自動的にビルドされます.
		</li>

		<li>src フォルダ直下の make_world.bat または make_world.sh により clean を実行した場合、libresslの配下は clean されません.

		<div class=box>
			<b><u>Note.</u></b>

			proj_list_skip_clean.bat(proj_list_skip_clean.sh) というファイルによって、これらが clean されないように設定してあります.
			なぜこのようにしているのかと言えば、libressl のコンパイルは時間がかかることと、Moai自体のバージョンが上がっても、libressl自体は通常はコンパイルし直す必要性はないものと考えられるからです.
		</div>

		<li>libressl単体をビルドしたい場合は、libressl フォルダ内に入り、その中にある make_world.bat または make_world.sh を実行します.
		尚、このフォルダ内で make_world.bat または make_world.sh により clean を実行した場合は、( src フォルダ直下の場合と異なり )今度は libressl 全体が clean されます.
		</li>
	</ul>
@@.

@@L about_macos
	現状では未サポートです.
	仮にコンパイルを試みるなら(手元にないので未確認ですが)Darwinを使うことになると思います.
	これにgcc, makeコマンドなどLinuxと同様のツールが含まれており、多分Makefile_linux.makを少し手直しすれば同様の方法でコンパイルできると考えられます.
	ダイナミックリンクライブラリの拡張子はsoではなくdylibやtbdといったものになるようです.
	その他リンカldのオプションもおそらくMacOS独自のものを指定しなければならないでしょう.
@@.

@@P Link
{ ['#TopBar'] ['一番上へ'] }
{ ['https://mr-moai-2016.github.io'] ['Moaiドキュメント(オンライン)'] }
{ ['https://github.com/mr-moai-2016/znk_project'] ['znk_project(github)'] }
@@.
